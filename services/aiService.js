const axios = require('axios');
const database = require('../database/init');

class AIService {
    constructor() {
        this.providers = {
            openai: {
                url: 'https://api.openai.com/v1/chat/completions',
                model: 'gpt-4-turbo-preview',
                maxTokens: 4000
            },
            claude: {
                url: 'https://api.anthropic.com/v1/messages',
                model: 'claude-3-sonnet-20240229',
                maxTokens: 4000
            },
            deepseek: {
                url: 'https://api.deepseek.com/v1/chat/completions',
                model: 'deepseek-chat',
                maxTokens: 4000
            }
        };

        this.financialPrompts = {
            consulta: `Voc√™ √© um analista financeiro especializado no mercado brasileiro. 
            Forne√ßa an√°lises t√©cnicas e fundamentalistas precisas, sempre baseadas em dados reais quando poss√≠vel.
            Use termos t√©cnicos adequados e seja espec√≠fico em suas recomenda√ß√µes.
            Sempre inclua disclaimers sobre riscos de investimento.`,

            daytrade: `Voc√™ √© um especialista em day trade focado nos futuros da B3 (WINFUT, INDFUT, DOLFUT, WDOFUT, BITFUT).
            Forne√ßa an√°lises t√©cnicas espec√≠ficas com pontos de entrada, stop loss e alvos.
            Considere volume, padr√µes de candlestick e indicadores t√©cnicos.
            Seja preciso com n√≠veis de pre√ßo e sempre mencione o gerenciamento de risco.`,

            portfolio: `Voc√™ √© um consultor de investimentos especializado em otimiza√ß√£o de portf√≥lios.
            Analise diversifica√ß√£o, correla√ß√µes entre ativos e perfil de risco.
            Forne√ßa recomenda√ß√µes de aloca√ß√£o baseadas em teoria moderna de portf√≥lio.
            Considere o cen√°rio macroecon√¥mico brasileiro e global.`,

            robot: `Voc√™ √© um programador especializado em desenvolvimento de rob√¥s de trading para a plataforma Nelogica.
            Use a linguagem NTFL (Nelogica Trading Formula Language).
            Forne√ßa c√≥digo limpo, comentado e test√°vel.
            Inclua explica√ß√µes sobre a l√≥gica da estrat√©gia e par√¢metros de configura√ß√£o.`
        };
    }

    async generateResponse(message, mode = 'consulta', userId = null, conversationHistory = []) {
        try {
            // Buscar conhecimento relevante no banco de dados
            const relevantKnowledge = await this.searchKnowledge(message, mode);
            
            // Construir contexto
            const context = await this.buildContext(message, mode, relevantKnowledge, conversationHistory);
            
            // Selecionar provedor de IA baseado na complexidade
            const provider = this.selectProvider(message, mode);
            
            // Gerar resposta
            const response = await this.callAIProvider(provider, context);
            
            // Registrar uso se houver usu√°rio
            if (userId) {
                await this.logUsage(userId, provider, response.tokensUsed || 100);
            }
            
            return {
                content: response.content,
                provider: provider,
                tokensUsed: response.tokensUsed || 100,
                model: this.providers[provider].model
            };
            
        } catch (error) {
            console.error('Erro no servi√ßo de IA:', error);
            return this.getFallbackResponse(mode);
        }
    }

    async searchKnowledge(query, mode) {
        try {
            // Buscar conhecimento relevante baseado em palavras-chave
            const keywords = this.extractKeywords(query);
            const knowledge = await database.all(
                `SELECT title, content, category, subcategory 
                 FROM financial_knowledge 
                 WHERE (title LIKE ? OR content LIKE ? OR tags LIKE ?)
                 ORDER BY relevance_score DESC 
                 LIMIT 5`,
                [`%${keywords.join('%')}%`, `%${keywords.join('%')}%`, `%${keywords.join('%')}%`]
            );
            
            return knowledge;
        } catch (error) {
            console.error('Erro ao buscar conhecimento:', error);
            return [];
        }
    }

    extractKeywords(text) {
        // Lista de palavras-chave do mercado financeiro
        const financialTerms = [
            'WINFUT', 'INDFUT', 'DOLFUT', 'WDOFUT', 'BITFUT',
            'bovespa', 'ibovespa', 'futuros', 'day trade', 'swing trade',
            'scalping', 'breakout', 'support', 'resistance', 'macd',
            'rsi', 'bollinger', 'fibonacci', 'candlestick', 'volume',
            'an√°lise t√©cnica', 'an√°lise fundamentalista'
        ];

        const words = text.toLowerCase().split(/\s+/);
        return words.filter(word => 
            financialTerms.some(term => 
                term.toLowerCase().includes(word) || word.includes(term.toLowerCase())
            ) || word.length > 4
        ).slice(0, 10);
    }

    buildContext(message, mode, knowledge, history) {
        let context = this.financialPrompts[mode] + '\n\n';
        
        // Adicionar conhecimento relevante
        if (knowledge.length > 0) {
            context += 'Conhecimento relevante:\n';
            knowledge.forEach(item => {
                context += `- ${item.title}: ${item.content}\n`;
            });
            context += '\n';
        }
        
        // Adicionar hist√≥rico da conversa (√∫ltimas 5 mensagens)
        if (history.length > 0) {
            context += 'Contexto da conversa:\n';
            const recentHistory = history.slice(-5);
            recentHistory.forEach(msg => {
                context += `${msg.role}: ${msg.content}\n`;
            });
            context += '\n';
        }
        
        context += `Pergunta do usu√°rio: ${message}\n\nResposta:`;
        
        return context;
    }

    selectProvider(message, mode) {
        // L√≥gica para selecionar o melhor provedor baseado no tipo de consulta
        if (mode === 'robot' || message.toLowerCase().includes('c√≥digo') || message.toLowerCase().includes('ntfl')) {
            return 'openai'; // GPT-4 √© melhor para c√≥digo
        }
        
        if (mode === 'daytrade' || message.toLowerCase().includes('an√°lise t√©cnica')) {
            return 'claude'; // Claude √© bom para an√°lises detalhadas
        }
        
        if (message.toLowerCase().includes('previs√£o') || message.toLowerCase().includes('tend√™ncia')) {
            return 'deepseek'; // DeepSeek para racioc√≠nio complexo
        }
        
        // Default para GPT-4
        return 'openai';
    }

    async callAIProvider(provider, context) {
        try {
            if (provider === 'openai') {
                return await this.callOpenAI(context);
            } else if (provider === 'claude') {
                return await this.callClaude(context);
            } else if (provider === 'deepseek') {
                return await this.callDeepSeek(context);
            }
        } catch (error) {
            console.error(`Erro no provedor ${provider}:`, error);
            // Fallback para mock response em desenvolvimento
            return this.getMockResponse();
        }
    }

    async callOpenAI(context) {
        const response = await axios.post(this.providers.openai.url, {
            model: this.providers.openai.model,
            messages: [{ role: 'user', content: context }],
            max_tokens: this.providers.openai.maxTokens,
            temperature: 0.7
        }, {
            headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                'Content-Type': 'application/json'
            }
        });

        return {
            content: response.data.choices[0].message.content,
            tokensUsed: response.data.usage.total_tokens
        };
    }

    async callClaude(context) {
        const response = await axios.post(this.providers.claude.url, {
            model: this.providers.claude.model,
            max_tokens: this.providers.claude.maxTokens,
            messages: [{ role: 'user', content: context }]
        }, {
            headers: {
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'Content-Type': 'application/json'
            }
        });

        return {
            content: response.data.content[0].text,
            tokensUsed: response.data.usage.input_tokens + response.data.usage.output_tokens
        };
    }

    async callDeepSeek(context) {
        const response = await axios.post(this.providers.deepseek.url, {
            model: this.providers.deepseek.model,
            messages: [{ role: 'user', content: context }],
            max_tokens: this.providers.deepseek.maxTokens,
            temperature: 0.7
        }, {
            headers: {
                'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                'Content-Type': 'application/json'
            }
        });

        return {
            content: response.data.choices[0].message.content,
            tokensUsed: response.data.usage.total_tokens
        };
    }

    getMockResponse() {
        const responses = [
            {
                content: `Baseado na an√°lise t√©cnica atual, identifiquei alguns pontos importantes:

üìä **An√°lise Geral do Mercado:**
‚Ä¢ IBOVESPA est√° testando resist√™ncia em 130.000 pontos
‚Ä¢ Volume m√©dio nas √∫ltimas sess√µes
‚Ä¢ Tend√™ncia de curto prazo lateral com vi√©s de alta

üìà **WINFUT - Recomenda√ß√µes:**
‚Ä¢ Suporte: 127.800 / 127.500
‚Ä¢ Resist√™ncia: 128.400 / 128.700
‚Ä¢ Estrat√©gia: Aguardar rompimento para definir dire√ß√£o

‚ö†Ô∏è **Gest√£o de Risco:**
‚Ä¢ Stop loss sempre abaixo do suporte identificado
‚Ä¢ Position size adequado ao seu capital
‚Ä¢ N√£o arrisque mais de 2% do capital por opera√ß√£o

*Esta an√°lise √© baseada em dados t√©cnicos e n√£o constitui recomenda√ß√£o de investimento. Sempre consulte um assessor financeiro.*`,
                tokensUsed: 150
            },
            {
                content: `An√°lise t√©cnica para Day Trade:

üéØ **WINFUT - Setup Atual:**
‚Ä¢ Pre√ßo: 128.100 pontos
‚Ä¢ Movimento lateral entre 127.800 e 128.400
‚Ä¢ MACD em diverg√™ncia positiva
‚Ä¢ RSI em 55 (neutro)

üìã **Estrat√©gia Sugerida:**
1. **Entrada Long:** Rompimento de 128.400 com volume
2. **Stop Loss:** 127.950 (45 pontos)
3. **Alvo 1:** 128.700 (30 pontos)
4. **Alvo 2:** 129.000 (60 pontos)

üîç **INDFUT - Observa√ß√µes:**
‚Ä¢ Maior volatilidade que WINFUT
‚Ä¢ Correla√ß√£o alta com IBOV
‚Ä¢ Requer maior capital devido ao tick

‚ö° **Dicas para Day Trade:**
‚Ä¢ Opere apenas nos hor√°rios de maior volume (10h-11h30 / 14h-16h)
‚Ä¢ Use ordens stop para prote√ß√£o autom√°tica
‚Ä¢ Acompanhe os √≠ndices americanos para conflu√™ncia

*Lembrando que day trade √© uma atividade de alto risco.*`,
                tokensUsed: 180
            }
        ];
        
        return responses[Math.floor(Math.random() * responses.length)];
    }

    getFallbackResponse(mode) {
        const fallbacks = {
            consulta: {
                content: "Desculpe, estou enfrentando dificuldades t√©cnicas no momento. Por favor, tente novamente em alguns minutos ou reformule sua pergunta.",
                tokensUsed: 50,
                provider: 'fallback',
                model: 'fallback'
            },
            daytrade: {
                content: "Sistema de an√°lise t√©cnica temporariamente indispon√≠vel. Para day trade, sempre lembre-se de usar stop loss e n√£o arriscar mais de 2% do capital por opera√ß√£o.",
                tokensUsed: 50,
                provider: 'fallback',
                model: 'fallback'
            },
            portfolio: {
                content: "Servi√ßo de an√°lise de portf√≥lio em manuten√ß√£o. Em breve estaremos de volta com an√°lises completas de diversifica√ß√£o e otimiza√ß√£o.",
                tokensUsed: 50,
                provider: 'fallback',
                model: 'fallback'
            },
            robot: {
                content: "Gerador de c√≥digo NTFL temporariamente offline. Consulte a documenta√ß√£o da Nelogica para refer√™ncias de programa√ß√£o.",
                tokensUsed: 50,
                provider: 'fallback',
                model: 'fallback'
            }
        };
        
        return fallbacks[mode] || fallbacks.consulta;
    }

    async logUsage(userId, provider, tokensUsed) {
        try {
            // Consumir cr√©ditos do usu√°rio (apenas para planos free/basic)
            const user = await database.get('SELECT plan, credits FROM users WHERE id = ?', [userId]);
            
            if (user && (user.plan === 'free' || user.plan === 'basic') && user.credits > 0) {
                await database.run(
                    'UPDATE users SET credits = credits - 1 WHERE id = ?',
                    [userId]
                );
            }
            
            // Registrar no log
            await database.run(
                `INSERT INTO api_logs (user_id, endpoint, method, status_code) 
                 VALUES (?, ?, ?, ?)`,
                [userId, 'ai_chat', 'POST', 200]
            );
            
        } catch (error) {
            console.error('Erro ao registrar uso:', error);
        }
    }
}

module.exports = new AIService();